<body style="display:flex; justify-content: center;">
    <div id="container"></div>
</body>
<!-- constantes -->
<script>
    const A = "A";
    const B = "B";
    const C = "C";
    const D = "D";
    const E = "E";
    const F = "F";
    const G = "G";

    const SEG = {
        2048 :[A,B],
        1024 :[B,C],
        512  :[C,D],
        256  :[D,E],
        128  :[E,F],
        64   :[F,A],
        32   :[G,A],
        16   :[G,B],
        8    :[G,C],
        4    :[G,D],
        2    :[G,E],
        1    :[G,F],
    }

    const legenda = false;

    const size = 100;
    const raio = 50;
    const corda = 40;
</script>
<!-- funções -->
<script>
    function gerarSubGrafos(tamanho){
        const listaGrafo = []
        const listaNumero = []

        // gera as combinações de segmentos
        let combinacoesPossiveis = combinacaoRecursiva([0,1,2,3,4,5,6,7,8,9,10,11], tamanho).map( x => {
            const vetor = Array(12).fill(0);
            x.forEach(pos => {
                vetor[pos] = 1;
            });
            return vetor;
        });

        // adiciona na lista final somente aquelas que não são repetições rotacionadas
        for (let subGrafo of combinacoesPossiveis){
            // debugger
            let novo = true;
            let copy = [...subGrafo];
            
            for(let r = 0; r < 6; r++){                
                let c0 = copy.slice(0,6);
                let c1 = copy.slice(6,12);
                let f0 = c0.shift();
                let f1 = c1.shift();
                copy = [...c0, f0,...c1, f1];

                if (listaNumero.some( x => x == parseInt(copy.join(""),2)))
                    novo = false;
            }

            if (novo) {
                listaGrafo.push(subGrafo);
                listaNumero.push(parseInt(subGrafo.join(""),2))
            }
        }

        return listaGrafo;

    }

    function combinacaoRecursiva(universo, tamanho) {
        const resultado = [];

        function backtrack(combinacao, inicio) {
            if (combinacao.length === tamanho) {
                resultado.push([...combinacao]);
                return;
            }
            for (let i = inicio; i < universo.length; i++) {
                combinacao.push(universo[i]);
                backtrack(combinacao, i + 1);
                combinacao.pop();
            }
        }

        backtrack([], 0);
        return resultado;
    }

    function desenharCaminho(caminho, context) {
        const vertices = ['D', 'E', 'F', 'A', 'B', 'C'];
        const angs = Array.from({length: 6}, (_, i) => 2 * Math.PI * i / 6);
        const pos = {};
        for (let i = 0; i < vertices.length; i++) {
            pos[vertices[i]] = [
                size/2 + raio * Math.cos(angs[i]),
                size/2 + raio * Math.sin(angs[i])
            ];
        }
        const pos2 = {};
        for (let i = 0; i < vertices.length; i++) {
            pos2[vertices[i]] = [
                size/2 + corda * Math.cos(angs[i]),
                size/2 + corda * Math.sin(angs[i])
            ];
        }
        pos['G'] = [size/2, size/2];

        // Cria canvas e contexto
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Desenha vértices
        if (legenda)
        for (const v in pos) {
            const [x, y] = pos[v];
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(v, x, y);
        }
        
        // Desenha fundo
        ctx.strokeStyle = '#eaeaea';
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.9;
        for (let k in SEG) {
            let f = SEG[k];
            let x0, y0;
            let x1, y1;
            if (f.join("").includes("G")){
                [x0, y0] = pos[f[0]];
                [x1, y1] = pos[f[1]];
            }
            else{
                [x0, y0] = pos2[f[0]];
                [x1, y1] = pos2[f[1]];
            }
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }

        // Desenha arestas do caminho
        // ctx.strokeStyle = '#e53935';
        ctx.strokeStyle = '#2089df';
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.50;
        for (let i = 0; i < caminho.length; i++) {
            let x0, y0;
            let x1, y1;
            if (caminho[i].join("").includes("G")){
                [x0, y0] = pos[caminho[i][0]];
                [x1, y1] = pos[caminho[i][1]];
            }
            else{
                [x0, y0] = pos2[caminho[i][0]];
                [x1, y1] = pos2[caminho[i][1]];
            }
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // Título
        if (legenda){
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`Caminho: ${caminho.map(x => x.join("")).join(',')}`, size/2, 20);
        }
        return canvas;
    }
        
    function desenharCaminhos(caminhos, ctx) {
        const vertices = ['D', 'E', 'F', 'A', 'B', 'C'];
        const angs = Array.from({length: 6}, (_, i) => 2 * Math.PI * i / 6);

        let [x, y] = [0, 0];
        for (let c = 0; c < caminhos.length; c++) {
            const caminho = caminhos[c];
            const centro = [raio + x*2*raio + (y%2)*(raio), raio + y*raio*Math.tan(Math.PI/3)];
            const pos = {};
            const pos2 = {};
            // debugger;
            const col = 12;
            [x,y] = [(x + 1)%(col - y%2), y + Math.floor((x + 1)/(col- y%2))];
            // i = i + Math.floor((j + 1)/(9 - i%2));
            // j = (j + 1)%(9 - i%2);
            
            //posições
            for (let i = 0; i < vertices.length; i++) {
                pos[vertices[i]] = [
                    centro[0] + raio * Math.cos(angs[i]),
                    centro[1] + raio * Math.sin(angs[i])
                ];
            }
            for (let i = 0; i < vertices.length; i++) {
                pos2[vertices[i]] = [
                    centro[0] + corda * Math.cos(angs[i]),
                    centro[1] + corda * Math.sin(angs[i])
                ];
            }
            pos['G'] = centro; //[size/2, size/2];
            
            // Desenha fundo
            ctx.strokeStyle = '#eaeaea';
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.9;
            for (let k in SEG) {
                let f = SEG[k];
                let x0, y0;
                let x1, y1;
                if (f.join("").includes("G")){                    
                    [x0, y0] = pos[f[0]];
                    [x1, y1] = pos[f[1]];
                }
                else{
                    [x0, y0] = pos2[f[0]];
                    [x1, y1] = pos2[f[1]];
                }
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }
            
            // Desenha arestas do caminho
            ctx.strokeStyle = '#2089df';
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.50;
            for (let i = 0; i < caminho.length; i++) {
                let x0, y0;
                let x1, y1;
                if (caminho[i].join("").includes("G")){
                    [x0, y0] = pos[caminho[i][0]];
                    [x1, y1] = pos[caminho[i][1]];
                }
                else{
                    [x0, y0] = pos2[caminho[i][0]];
                    [x1, y1] = pos2[caminho[i][1]];
                }
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }


            ctx.globalAlpha = 1.0;


            // i = i + Math.floor((j + 1)/(9 - i%2));
            // j = (j + 1)%(9 - i%2);
        }
        
        // return canvas;
    }
        
    function mostrarCaminhosNoGrid(caminhos, tamanho) {
        const container = document.getElementById('container');        

        caminhos.sort(() => Math.random() - 0.5);;

        for (let n = 0; n < tamanho; n++) {
            const div = document.createElement('div');
            // div.style.border = '1px solid #ccc';
            // div.style.padding = '8px';
            // div.style.background = '#fafafa';
            div.style.display = 'flex';
            div.style.flexDirection = 'column';
            div.style.alignItems = 'center';
            
            // Cria canvas e contexto
            const canvas = document.createElement('canvas');
            canvas.width = 1200;
            canvas.height = 190*Math.floor(letras/23);
            const ctx = canvas.getContext('2d');

            div.appendChild(canvas);
            desenharCaminhos(caminhos.slice(letras * n, letras * (n+1)), ctx)
        
            container.appendChild(div);
        }
        
        
    }

    function transduzirCaminhos(caminhos){
        // debugger
        return caminhos.map(x => {
            let grafo = [];

            x.reverse().map((y, n, arr) => {
                if ((y * (2**(n))) > 0)
                    grafo.push([...SEG[(y * (2**(n)))]])
            })
            return grafo;
        });
    }
</script>
<!-- excecução -->
<script>
    // debugger;
    let params = new URLSearchParams(document.location.search);
    let frases = params.get("size"); // tamanho
    let qtd = params.get("hexes"); // tamanho

    let tamanho = frases == null ? 3 : parseInt(frases);
    let letras = qtd == null ? 23: parseInt(qtd) * 23;
    let listaGrafos = []
    for (let t = 1; t <= 12; t++) {
        listaGrafos = listaGrafos.concat(gerarSubGrafos(t));
    } 

    // debugger;
    mostrarCaminhosNoGrid(transduzirCaminhos(listaGrafos), tamanho, letras)

</script>